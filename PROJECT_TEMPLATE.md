# PROJECT_TEMPLATE.md

Comprehensive guide for AI agents and developers scaffolding new Go projects that depend on `github.com/jasoet/pkg/v2`.

> **Audience:** AI code-generation agents (Claude, Cursor, Copilot) and human developers.
> **Scope:** Consumer projects — applications built _with_ this library, not contributions _to_ it.
> **Prerequisite:** Go 1.24+ (generics required).

---

## 1. Recommended Directory Layout

```
myapp/
├── cmd/
│   ├── server/
│   │   └── main.go              # API server entry point
│   └── worker/
│       └── main.go              # Temporal worker entry point
├── internal/
│   ├── config/
│   │   └── config.go            # AppConfig struct + loader
│   ├── model/
│   │   └── user.go              # GORM models
│   ├── repository/
│   │   └── user_repo.go         # Data access layer
│   ├── service/
│   │   └── user_service.go      # Business logic
│   ├── handler/
│   │   ├── user_handler.go      # HTTP handlers with swagger annotations
│   │   └── dto.go               # Request/Response DTOs (exported for swag)
│   ├── temporal/
│   │   ├── workflows.go         # Workflow definitions
│   │   └── activities.go        # Activity implementations
│   └── testutil/
│       └── db.go                # Shared test helpers (testcontainer DB, etc.)
├── migrations/
│   ├── embed.go                 # //go:embed for migration files
│   ├── 000001_create_users.up.sql
│   └── 000001_create_users.down.sql
├── test/
│   └── e2e/
│       ├── setup_test.go        # testServer, HTTP helpers, startTestServer()
│       └── api_test.go          # Full-stack API tests
├── docs/
│   ├── docs.go                  # Generated by swag init
│   ├── swagger.json
│   └── swagger.yaml
├── http/
│   └── api.http                 # IntelliJ/VS Code REST Client file
├── docker/
│   └── compose.yml              # Dev infrastructure (PostgreSQL, etc.)
├── tools.go                     # //go:build tools — pin swag, testcontainers, etc.
├── Taskfile.yml                 # Task runner configuration
├── config.yaml                  # Default configuration
├── go.mod
└── go.sum
```

| Directory | Purpose |
|-----------|---------|
| `cmd/server/` | API server entry point — config load, wiring, server start |
| `cmd/worker/` | Temporal worker entry point — registers workflows/activities |
| `internal/config/` | `AppConfig` struct with YAML + env var support |
| `internal/model/` | GORM model structs with table name methods |
| `internal/repository/` | Database access, one repo per aggregate |
| `internal/service/` | Business logic, orchestrates repositories |
| `internal/handler/` | Echo HTTP handlers + DTOs + swagger annotations |
| `internal/temporal/` | Workflow definitions and activity implementations |
| `internal/testutil/` | Shared test helpers (testcontainer setup, fixtures) |
| `migrations/` | SQL migration files with `embed.FS` |
| `test/e2e/` | End-to-end API tests against real HTTP + real DB |
| `docs/` | Generated Swagger/OpenAPI files (committed) |
| `http/` | `.http` files for manual API testing |
| `docker/` | Docker Compose files for dev infrastructure |

---

## 2. Configuration (3-Layer Strategy)

### Layer 1: YAML File

```go
type AppConfig struct {
    Server struct {
        Port            int           `yaml:"port" mapstructure:"port" validate:"required,min=1,max=65535"`
        ShutdownTimeout time.Duration `yaml:"shutdownTimeout" mapstructure:"shutdownTimeout"`
    } `yaml:"server" mapstructure:"server"`

    Database db.ConnectionConfig `yaml:"database" mapstructure:"database"`

    Temporal temporal.Config `yaml:"temporal" mapstructure:"temporal"`

    Auth struct {
        SessionDuration time.Duration `yaml:"sessionDuration" mapstructure:"sessionDuration"`
        BcryptCost      int           `yaml:"bcryptCost" mapstructure:"bcryptCost"`
    } `yaml:"auth" mapstructure:"auth"`
}
```

```go
cfg, err := config.LoadString[AppConfig](yamlContent, "APP")
```

- `envPrefix` is variadic — defaults to `"ENV"` if omitted.
- Struct tags: always include `yaml`, `mapstructure`, and `validate`.

### Layer 2: Environment Variable Overrides

Automatic via Viper: `APP_SERVER_PORT=9090` overrides `server.port`.

For deeply nested structs, use:

```go
config.NestedEnvVars("APP", 3, "database", viperInstance)
```

### Layer 3: Runtime Functional Options

```go
pool, err := cfg.Database.Pool() // OTelConfig injected at runtime, not from YAML
```

**Rule:** `OTelConfig *otel.Config` fields must always use `yaml:"-" mapstructure:"-"` tags. Never serialize OTel config — inject it at runtime via functional options or direct assignment.

---

## 3. OpenTelemetry Wiring

### Bootstrap

```go
// Create OTel config with service name
otelCfg := otel.NewConfig("myapp")

// Optionally attach real providers (nil = no-op, zero overhead)
otelCfg = otelCfg.
    WithTracerProvider(tracerProvider).
    WithMeterProvider(meterProvider)

// For OTel-based logging (replaces zerolog global)
loggerProvider, err := otel.NewLoggerProviderWithOptions("myapp",
    otel.WithConsoleOutput(true),
    otel.WithLogLevel(otel.LogLevel("info")),
)
otelCfg = otelCfg.WithLoggerProvider(loggerProvider)

// Store in context for downstream access
ctx = otel.ContextWithConfig(ctx, otelCfg)
```

### Pass to Components

```go
// Database — direct field assignment
cfg.Database.OTelConfig = otelCfg
pool, err := cfg.Database.Pool()

// REST client — functional option
client := rest.NewClient(
    rest.WithOTelConfig(otelCfg),
    rest.WithRestConfig(restCfg),
)

// Retry — builder method (value receiver)
retryCfg := retry.DefaultConfig().
    WithName("db.connect").
    WithOTel(otelCfg)
```

### No-Op Pattern

When `OTelConfig` is `nil` or providers are `nil`, all instrumentation becomes no-op with zero runtime overhead. No nil-checks needed in application code.

---

## 4. Architecture Layers + Instrumentation

### Layer Separation

```
HTTP Request → Handler → Service → Repository → Database
                 ↓           ↓           ↓
            StartHandler  StartService  StartRepository
```

### Using LayerContext

Each layer gets its own `LayerContext` from `otel.Layers`:

```go
func (s *UserService) Create(ctx context.Context, req CreateUserRequest) (*User, error) {
    lc := otel.Layers.StartService(ctx, "user", "Create",
        otel.F("username", req.Username))
    defer lc.End()

    lc.Logger.Info("Creating user")

    user, err := s.repo.Save(lc.Context(), req.ToModel())
    if err != nil {
        return nil, lc.Error(err, "failed to save user")
    }

    lc.Success("User created")
    return user, nil
}
```

**Available start methods:**

| Method | Layer | SpanKind |
|--------|-------|----------|
| `Layers.StartHandler(ctx, component, operation, fields...)` | Handler | Server |
| `Layers.StartService(ctx, component, operation, fields...)` | Service | Internal |
| `Layers.StartRepository(ctx, component, operation, fields...)` | Repository | Client |
| `Layers.StartOperations(ctx, component, operation, fields...)` | Operations | Internal |
| `Layers.StartMiddleware(ctx, component, operation, fields...)` | Middleware | Server |

**Naming convention:**
- Tracer name: `{layer}.{component}` (e.g., `service.user`)
- Span name: `{component}.{operation}` (e.g., `user.Create`)

**LayerContext methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `lc.Context()` | `context.Context` | Pass to downstream calls |
| `lc.Error(err, msg, fields...)` | `error` | Log error + set span error + return the error |
| `lc.Success(msg, fields...)` | _(void)_ | Log success at info level |
| `lc.End()` | _(void)_ | End the span (always defer) |

---

## 5. Database Setup

### Connection Pool

```go
pool, err := db.ConnectionConfig{
    DbType:     db.Postgresql,
    Host:       cfg.Database.Host,
    Port:       cfg.Database.Port,
    Username:   cfg.Database.Username,
    Password:   cfg.Database.Password,
    DbName:     cfg.Database.DbName,
    OTelConfig:  otelCfg, // Automatic query tracing
}.Pool()
```

### Migrations with embed.FS

```go
// migrations/embed.go
package migrations

import "embed"

//go:embed *.sql
var FS embed.FS
```

```go
// In main.go
err := db.RunPostgresMigrationsWithGorm(ctx, pool, migrations.FS, ".")
```

**Migration file naming:** `{sequence}_{description}.{up|down}.sql`

```
000001_create_users.up.sql
000001_create_users.down.sql
000002_add_sessions.up.sql
000002_add_sessions.down.sql
```

---

## 6. HTTP Server

### Starting the Server

```go
serverCfg := server.Config{
    Port: cfg.Server.Port,
    ShutdownTimeout: cfg.Server.ShutdownTimeout,
    Middleware: []echo.MiddlewareFunc{
        middleware.Recover(),
        middleware.Logger(),
    },
    EchoConfigurer: func(e *echo.Echo) {
        // Register all routes here
        e.GET("/swagger/*", echoSwagger.WrapHandler)

        apiV1 := e.Group("/api/v1")
        userHandler.RegisterRoutes(apiV1.Group("/users"))
    },
    Operation: func(e *echo.Echo) {
        // Additional startup operations
    },
    Shutdown: func(e *echo.Echo) {
        // Cleanup: close DB pools, flush telemetry, etc.
        sqlDB, _ := pool.DB()
        _ = sqlDB.Close()
    },
}

server.StartWithConfig(serverCfg)
```

### Built-in Health Endpoints

The `server` package automatically registers:

| Endpoint | Response |
|----------|----------|
| `GET /` | `200 "Home"` |
| `GET /health` | `200 {"status": "UP"}` |
| `GET /health/ready` | `200 {"status": "READY"}` |
| `GET /health/live` | `200 {"status": "ALIVE"}` |

**Note:** `server.Config` does not have an `OTelConfig` field. Inject OTel middleware through the `Middleware` slice or inside `EchoConfigurer`.

---

## 7. gRPC Server (Optional)

> Use this instead of (or alongside) the HTTP server when your project exposes gRPC services. The `grpc` package supports two modes: **H2C** (gRPC + HTTP on a single port, default) and **Separate** (gRPC and HTTP on different ports). Both include an Echo-based HTTP gateway automatically.

### H2C Mode (Recommended for Most Projects)

Single port serves both gRPC and REST via HTTP/2 cleartext:

```go
import (
    "github.com/jasoet/pkg/v2/grpc"
    "google.golang.org/grpc"
    pb "myapp/proto/gen"
)

server, err := grpc.New(
    grpc.WithGRPCPort("8080"),
    grpc.WithOTelConfig(otelCfg),
    grpc.WithServiceRegistrar(func(s *grpc.Server) {
        pb.RegisterMyServiceServer(s, &myServiceImpl{})
    }),
    grpc.WithEchoConfigurer(func(e *echo.Echo) {
        // Additional REST routes alongside gRPC
        e.GET("/swagger/*", echoSwagger.WrapHandler)
    }),
    grpc.WithShutdownHandler(func() error {
        sqlDB, _ := pool.DB()
        return sqlDB.Close()
    }),
)
if err != nil {
    log.Fatal(err)
}
server.Start()
```

### Separate Mode

gRPC on one port, HTTP gateway on another:

```go
server, err := grpc.New(
    grpc.WithSeparateMode("9090", "8080"), // gRPC:9090, HTTP:8080
    grpc.WithOTelConfig(otelCfg),
    grpc.WithServiceRegistrar(func(s *grpc.Server) {
        pb.RegisterMyServiceServer(s, &myServiceImpl{})
    }),
)
```

### Convenience Starters

```go
// H2C mode — single call, blocks until signal
grpc.StartH2C("8080", func(s *grpc.Server) {
    pb.RegisterMyServiceServer(s, &myServiceImpl{})
}, grpc.WithOTelConfig(otelCfg))

// Separate mode
grpc.StartSeparate("9090", "8080", func(s *grpc.Server) {
    pb.RegisterMyServiceServer(s, &myServiceImpl{})
})
```

### Built-in Features

All enabled by default (toggle with `Without*()` options):

| Feature | Option | Default |
|---------|--------|---------|
| Health checks (`/health`, `/health/ready`, `/health/live`) | `WithHealthCheck()` / `WithoutHealthCheck()` | Enabled |
| Prometheus metrics (`/metrics`) | `WithMetrics()` / `WithoutMetrics()` | Enabled |
| gRPC reflection | `WithReflection()` / `WithoutReflection()` | Enabled |
| Request logging | `WithLogging()` / `WithoutLogging()` | Enabled |
| CORS | `WithCORS()` | Disabled |
| Rate limiting | `WithRateLimit(rps)` | Disabled |

### Key Options Reference

```go
// Ports & Mode
grpc.WithGRPCPort("9090")
grpc.WithSeparateMode("9090", "8080")
grpc.WithH2CMode()

// Service registration
grpc.WithServiceRegistrar(func(s *grpc.Server) { ... })

// HTTP gateway customization
grpc.WithEchoConfigurer(func(e *echo.Echo) { ... })
grpc.WithGatewayBasePath("/api/v1")  // default
grpc.WithMiddleware(mw1, mw2)

// Lifecycle
grpc.WithShutdownHandler(func() error { ... })
grpc.WithShutdownTimeout(30 * time.Second)

// Observability
grpc.WithOTelConfig(otelCfg)  // Replaces Prometheus with OTel when set
```

### Directory Layout Addition

When using gRPC, add a `proto/` directory to your project:

```
myapp/
├── proto/
│   ├── myservice.proto         # Protobuf definitions
│   └── gen/                    # Generated Go code (buf generate or protoc)
│       ├── myservice.pb.go
│       └── myservice_grpc.pb.go
```

---

## 8. Temporal Workers & Workflows

If your application needs async jobs, background processing, or scheduled tasks, use the `temporal` package.

### Config

`temporal.Config` is a plain serializable struct (no `OTelConfig` field — unlike most other packages):

```go
import "github.com/jasoet/pkg/v2/temporal"

// In AppConfig:
Temporal temporal.Config `yaml:"temporal" mapstructure:"temporal"`
```

```yaml
# config.yaml
temporal:
  hostPort: localhost:7233
  namespace: default
  metricsListenAddress: "0.0.0.0:9090"
```

### Defining Workflows and Activities

```go
// internal/temporal/workflows.go
package temporal

import (
    "go.temporal.io/sdk/workflow"
)

func OrderProcessingWorkflow(ctx workflow.Context, orderID string) (*OrderResult, error) {
    opts := workflow.ActivityOptions{
        StartToCloseTimeout: 30 * time.Second,
    }
    ctx = workflow.WithActivityOptions(ctx, opts)

    // Execute activities in sequence
    var validated bool
    if err := workflow.ExecuteActivity(ctx, ValidateOrderActivity, orderID).Get(ctx, &validated); err != nil {
        return nil, err
    }

    var result OrderResult
    if err := workflow.ExecuteActivity(ctx, ProcessPaymentActivity, orderID).Get(ctx, &result); err != nil {
        return nil, err
    }

    return &result, nil
}
```

```go
// internal/temporal/activities.go
package temporal

import "context"

// Activities struct holds injected dependencies (repos, services, etc.)
type Activities struct {
    orderRepo *repository.OrderRepo
    paymentSvc *service.PaymentService
}

func NewActivities(orderRepo *repository.OrderRepo, paymentSvc *service.PaymentService) *Activities {
    return &Activities{orderRepo: orderRepo, paymentSvc: paymentSvc}
}

func (a *Activities) ValidateOrderActivity(ctx context.Context, orderID string) (bool, error) {
    order, err := a.orderRepo.FindByID(ctx, orderID)
    if err != nil {
        return false, err
    }
    return order.IsValid(), nil
}

func (a *Activities) ProcessPaymentActivity(ctx context.Context, orderID string) (*OrderResult, error) {
    return a.paymentSvc.Process(ctx, orderID)
}
```

### Worker Binary (`cmd/worker/main.go`)

```go
package main

import (
    "context"
    "flag"
    "log"

    "go.temporal.io/sdk/worker"

    appconfig "myapp/internal/config"
    apptemporal "myapp/internal/temporal"
    "myapp/internal/repository"
    "myapp/internal/service"
    "myapp/migrations"

    "github.com/jasoet/pkg/v2/db"
    "github.com/jasoet/pkg/v2/temporal"
)

const taskQueue = "myapp-tasks"

func main() {
    configPath := flag.String("config", "config.yaml", "path to config file")
    flag.Parse()

    cfg, err := appconfig.Load(*configPath)
    if err != nil {
        log.Fatalf("failed to load config: %v", err)
    }

    // Database (activities need repos)
    pool, err := cfg.Database.Pool()
    if err != nil {
        log.Fatalf("failed to connect to database: %v", err)
    }
    if err := db.RunPostgresMigrationsWithGorm(context.Background(), pool, migrations.FS, "."); err != nil {
        log.Fatalf("failed to run migrations: %v", err)
    }

    // Build activity dependencies
    orderRepo := repository.NewOrderRepo(pool)
    paymentSvc := service.NewPaymentService(orderRepo)
    activities := apptemporal.NewActivities(orderRepo, paymentSvc)

    // Create WorkerManager (owns its own Temporal client)
    wm, err := temporal.NewWorkerManager(&cfg.Temporal)
    if err != nil {
        log.Fatalf("failed to create worker manager: %v", err)
    }
    defer wm.Close()

    // Register worker with workflows and activities
    w := wm.Register(taskQueue, worker.Options{})
    w.RegisterWorkflow(apptemporal.OrderProcessingWorkflow)
    w.RegisterActivity(activities)  // registers all methods on the struct

    // Start worker (blocks until interrupted)
    log.Printf("Starting worker on task queue: %s", taskQueue)
    if err := wm.StartAll(context.Background()); err != nil {
        log.Fatalf("worker failed: %v", err)
    }
}
```

### Triggering Workflows from the API Server

```go
// In your handler or service:
temporalClient, err := temporal.NewClient(&cfg.Temporal)
if err != nil {
    return err
}
defer temporalClient.Close()

run, err := temporalClient.ExecuteWorkflow(ctx,
    client.StartWorkflowOptions{
        ID:        fmt.Sprintf("order-%s", orderID),
        TaskQueue: "myapp-tasks",
    },
    apptemporal.OrderProcessingWorkflow, orderID,
)
```

### Schedule Management

For recurring jobs (e.g., periodic sync, cleanup):

```go
sm := temporal.NewScheduleManager(temporalClient)

handle, err := sm.CreateWorkflowSchedule(ctx, "daily-cleanup", temporal.WorkflowScheduleOptions{
    WorkflowID: "cleanup-workflow",
    Workflow:    apptemporal.CleanupWorkflow,
    TaskQueue:   "myapp-tasks",
    Interval:    24 * time.Hour,
    Args:        []interface{}{"arg1"},
})

// List, update, delete schedules
schedules, _ := sm.ListSchedules(ctx, 10)
sm.DeleteSchedule(ctx, "daily-cleanup")
```

### Temporal Testcontainer

For integration tests against a real Temporal server:

```go
//go:build integration

import "github.com/jasoet/pkg/v2/temporal/testcontainer"

func TestWorkflow(t *testing.T) {
    ctx := context.Background()

    // One-call setup: container + client + cleanup
    container, temporalClient, cleanup, err := testcontainer.Setup(
        ctx,
        testcontainer.ClientConfig{Namespace: "default"},
        testcontainer.Options{Logger: t},
    )
    require.NoError(t, err)
    defer cleanup()

    // Use temporalClient to start workflows, create workers, etc.
}
```

### Docker Compose for Development

```yaml
# docker/compose.yml (add alongside PostgreSQL)
services:
  temporal:
    image: temporalio/auto-setup:latest
    ports:
      - "7233:7233"
    environment:
      DB: postgresql
      DB_PORT: 5432
      POSTGRES_USER: postgres
      POSTGRES_PWD: postgres
      POSTGRES_SEEDS: postgres
    depends_on:
      - postgres

  temporal-ui:
    image: temporalio/ui:latest
    ports:
      - "8233:8080"
    environment:
      TEMPORAL_ADDRESS: temporal:7233
    depends_on:
      - temporal
```

---

## 9. Testing Strategy (4 Tiers)

### Tier 1: Unit Tests (no build tag)

```go
package service_test

func TestUserService_Create(t *testing.T) {
    // No Docker, no network — pure logic tests
    result, err := svc.Create(ctx, req)
    require.NoError(t, err)
    assert.Equal(t, "alice", result.Username)
}
```

Run: `go test ./... -short`

### Tier 2: Integration Tests (`//go:build integration`)

```go
//go:build integration

package repository_test

func TestUserRepo_Integration(t *testing.T) {
    pool := testutil.SetupTestDB(t)  // Testcontainer PostgreSQL
    repo := repository.NewUserRepo(pool)

    user, err := repo.Create(ctx, model)
    require.NoError(t, err)
    assert.NotZero(t, user.ID)
}
```

Run: `go test ./internal/... -tags=integration -v -count=1 -timeout 300s`

### Tier 3: E2E Tests (`//go:build integration` in `test/e2e/`)

Full-stack API tests: real HTTP server + real database. See [Section 10](#10-e2e-test-pattern) below.

Run: `go test ./test/e2e/ -tags=integration -v -count=1 -timeout 300s`

### Tier 4: Example Code (`//go:build example`)

```go
//go:build example

package main

func main() {
    // Runnable demonstration
}
```

Run: `go run -tags=example ./examples/...`

### Assertion Library

Always use `github.com/stretchr/testify`:

```go
import (
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

require.NoError(t, err)     // Fail immediately if error
assert.Equal(t, want, got)  // Continue on failure
```

---

## 10. E2E Test Pattern

> This is the pattern AI agents most commonly miss. E2E tests verify the full stack — real HTTP requests against a real server backed by a real database.

### `test/e2e/setup_test.go`

```go
//go:build integration

package e2e

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net"
    "net/http"
    "testing"

    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"

    "myapp/internal/handler"
    "myapp/internal/repository"
    "myapp/internal/service"
    "myapp/internal/testutil"
)

// testServer holds everything needed to interact with a running test API server.
type testServer struct {
    BaseURL string
    Echo    *echo.Echo
}

// startTestServer boots the full API stack against a real PostgreSQL container.
// It replicates the wiring from cmd/server/main.go but listens on a random port.
func startTestServer(t *testing.T) *testServer {
    t.Helper()

    // Real database via testcontainer
    pool := testutil.SetupTestDB(t)

    // Wire the same layers as cmd/server/main.go
    userRepo := repository.NewUserRepo(pool)
    userSvc := service.NewUserService(userRepo)
    userHandler := handler.NewUserHandler(userSvc)

    e := echo.New()
    e.HideBanner = true
    e.Use(middleware.Recover())

    // Health (replicates server package behavior)
    e.GET("/health", func(c echo.Context) error {
        return c.JSON(http.StatusOK, map[string]string{"status": "UP"})
    })

    // App routes (same wiring as production)
    apiV1 := e.Group("/api/v1")
    userHandler.RegisterRoutes(apiV1.Group("/users"))

    // Listen on random port
    ln, err := net.Listen("tcp", "127.0.0.1:0")
    if err != nil {
        t.Fatalf("failed to listen: %v", err)
    }
    e.Listener = ln

    go func() {
        if err := e.Start(""); err != nil && err != http.ErrServerClosed {
            // Server stopped
        }
    }()

    t.Cleanup(func() {
        _ = e.Close()
    })

    return &testServer{
        BaseURL: fmt.Sprintf("http://%s", ln.Addr().String()),
        Echo:    e,
    }
}

// --- HTTP helpers ---

func (ts *testServer) get(t *testing.T, path, token string) *http.Response {
    t.Helper()
    req, _ := http.NewRequest(http.MethodGet, ts.BaseURL+path, nil)
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    return resp
}

func (ts *testServer) postJSON(t *testing.T, path string, body interface{}, token string) *http.Response {
    t.Helper()
    jsonBody, _ := json.Marshal(body)
    req, _ := http.NewRequest(http.MethodPost, ts.BaseURL+path, bytes.NewReader(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    return resp
}

func (ts *testServer) putJSON(t *testing.T, path string, body interface{}, token string) *http.Response {
    t.Helper()
    jsonBody, _ := json.Marshal(body)
    req, _ := http.NewRequest(http.MethodPut, ts.BaseURL+path, bytes.NewReader(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    return resp
}

func (ts *testServer) delete(t *testing.T, path, token string) *http.Response {
    t.Helper()
    req, _ := http.NewRequest(http.MethodDelete, ts.BaseURL+path, nil)
    if token != "" {
        req.Header.Set("Authorization", "Bearer "+token)
    }
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    return resp
}

func readBody(t *testing.T, resp *http.Response) []byte {
    t.Helper()
    defer resp.Body.Close()
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        t.Fatalf("failed to read body: %v", err)
    }
    return body
}

func parseJSON(t *testing.T, resp *http.Response) map[string]interface{} {
    t.Helper()
    body := readBody(t, resp)
    var result map[string]interface{}
    if err := json.Unmarshal(body, &result); err != nil {
        t.Fatalf("failed to parse JSON: %v\nbody: %s", err, string(body))
    }
    return result
}

func parseJSONArray(t *testing.T, resp *http.Response) []map[string]interface{} {
    t.Helper()
    body := readBody(t, resp)
    var result []map[string]interface{}
    if err := json.Unmarshal(body, &result); err != nil {
        t.Fatalf("failed to parse JSON array: %v\nbody: %s", err, string(body))
    }
    return result
}

// login authenticates and returns the session token.
func (ts *testServer) login(t *testing.T, username, password string) string {
    t.Helper()
    resp := ts.postJSON(t, "/api/v1/auth/login", map[string]string{
        "username": username,
        "password": password,
    }, "")
    if resp.StatusCode != http.StatusOK {
        body := readBody(t, resp)
        t.Fatalf("login failed: %d %s", resp.StatusCode, string(body))
    }
    result := parseJSON(t, resp)
    return result["token"].(string)
}
```

### `test/e2e/api_test.go`

```go
//go:build integration

package e2e

import (
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestHealthEndpoint(t *testing.T) {
    ts := startTestServer(t)
    resp := ts.get(t, "/health", "")
    assert.Equal(t, http.StatusOK, resp.StatusCode)
    result := parseJSON(t, resp)
    assert.Equal(t, "UP", result["status"])
}

func TestUserCRUD(t *testing.T) {
    ts := startTestServer(t)
    token := ts.login(t, "admin", "changeme")

    // Create
    resp := ts.postJSON(t, "/api/v1/users", map[string]string{
        "username": "alice",
        "email":    "alice@example.com",
        "password": "secret123",
    }, token)
    require.Equal(t, http.StatusCreated, resp.StatusCode)
    created := parseJSON(t, resp)
    assert.Equal(t, "alice", created["username"])

    // List
    resp = ts.get(t, "/api/v1/users", token)
    require.Equal(t, http.StatusOK, resp.StatusCode)
    users := parseJSONArray(t, resp)
    assert.GreaterOrEqual(t, len(users), 1)

    // Delete
    resp = ts.delete(t, "/api/v1/users/2", token)
    assert.Equal(t, http.StatusNoContent, resp.StatusCode)
    _ = readBody(t, resp)
}
```

**Key design decisions:**
- Each test calls `startTestServer(t)` — full isolation via fresh testcontainer DB.
- Uses `//go:build integration` tag (same as integration tests) since it needs Docker.
- HTTP helpers (`get`, `postJSON`, `putJSON`, `delete`) live on `testServer` struct.
- `login()` helper handles auth token extraction.
- Test scenarios: CRUD lifecycle, auth lifecycle, role enforcement, edge cases (duplicates, invalid input).

---

## 11. Swagger/OpenAPI

> Second most commonly missed pattern. Swagger provides auto-generated API docs and a test UI.

### Step 1: Pin the Tool

```go
// tools.go
//go:build tools

package tools

import _ "github.com/swaggo/swag/cmd/swag"
```

### Step 2: Main Function Annotations

```go
// cmd/server/main.go

import _ "myapp/docs" // swagger generated docs

// @title My App API
// @version 1.0
// @description REST API for My App
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Enter your session token with the `Bearer ` prefix
func main() {
    // ...
}
```

### Step 3: Handler Method Annotations

```go
// @Summary Create user
// @Description Create a new user account
// @Tags users
// @Accept json
// @Produce json
// @Param body body CreateUserRequest true "User data"
// @Success 201 {object} UserResponse
// @Failure 400 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse
// @Security BearerAuth
// @Router /api/v1/users [post]
func (h *UserHandler) Create(c echo.Context) error {
    // ...
}
```

### Step 4: DTOs in `handler/dto.go`

Define exported structs so `swag` can parse them:

```go
package handler

// ErrorResponse represents an error response.
type ErrorResponse struct {
    Error string `json:"error" example:"error message"`
}

// CreateUserRequest represents the create user request body.
type CreateUserRequest struct {
    Username string `json:"username" example:"johndoe"`
    Email    string `json:"email" example:"john@example.com"`
    Password string `json:"password" example:"secret123"`
    Role     string `json:"role" example:"viewer"`
}

// UserResponse represents a user in API responses.
type UserResponse struct {
    ID       int    `json:"id" example:"1"`
    Username string `json:"username" example:"admin"`
    Email    string `json:"email" example:"admin@example.com"`
    Role     string `json:"role" example:"admin"`
}
```

- Use `example` struct tags for Swagger example values.
- Keep DTOs separate from GORM models — handler layer maps between them.

### Step 5: Serve Swagger UI

```go
import echoSwagger "github.com/swaggo/echo-swagger"

// Inside EchoConfigurer or Operation callback:
e.GET("/swagger/*", echoSwagger.WrapHandler)
```

### Step 6: Generate

```bash
swag init -g cmd/server/main.go -o docs --parseDependency --parseInternal
```

Commit the generated `docs/` directory. Re-run after any annotation changes.

---

## 12. .http File Conventions

> Third most commonly missed pattern. `.http` files enable one-click API testing in IntelliJ and VS Code (REST Client extension).

Place in `http/api.http`:

```http
### Variables
@host = http://localhost:8080
@contentType = application/json

### ==========================================================
### Auth
### ==========================================================

### Login as admin
POST {{host}}/api/v1/auth/login
Content-Type: {{contentType}}

{
  "username": "admin",
  "password": "changeme"
}

> {%
client.global.set("token", response.body.token);
%}

### Get current user
GET {{host}}/api/v1/auth/me
Authorization: Bearer {{token}}

### Logout
POST {{host}}/api/v1/auth/logout
Authorization: Bearer {{token}}

### ==========================================================
### Users (Admin only)
### ==========================================================

### List all users
GET {{host}}/api/v1/users
Authorization: Bearer {{token}}

### Create user
POST {{host}}/api/v1/users
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "username": "viewer1",
  "email": "viewer1@example.com",
  "password": "password123",
  "role": "viewer"
}

### Update user (change ID as needed)
PUT {{host}}/api/v1/users/2
Content-Type: {{contentType}}
Authorization: Bearer {{token}}

{
  "role": "admin"
}

### Delete user (change ID as needed)
DELETE {{host}}/api/v1/users/2
Authorization: Bearer {{token}}

### ==========================================================
### Health
### ==========================================================

### Health check
GET {{host}}/health

### Swagger UI
GET {{host}}/swagger/index.html
```

**Conventions:**
- `@host` variable at the top — change once for different environments.
- `> {% ... %}` response handler scripts capture tokens after login.
- `### =====` section headers group endpoints by resource.
- Cover every API endpoint with realistic example payloads.
- Keep request bodies minimal but complete.

---

## 13. Taskfile Configuration

```yaml
version: "3"

vars:
  BIN_DIR: ./bin

tasks:
  default:
    desc: List all available tasks
    cmds:
      - task --list-all

  # --- Infrastructure ---
  infra:up:
    desc: Start dev infrastructure (PostgreSQL, Temporal, etc.)
    cmds:
      - docker compose -f docker/compose.yml up -d

  infra:down:
    desc: Stop dev infrastructure
    cmds:
      - docker compose -f docker/compose.yml down

  # --- Development ---
  dev:api:
    desc: Run the API server locally
    cmds:
      - go run ./cmd/server

  dev:worker:
    desc: Run the Temporal worker locally
    cmds:
      - go run ./cmd/worker

  # --- Test ---
  test:unit:
    desc: Run unit tests (short mode, no Docker)
    cmds:
      - go test ./... -short -v

  test:integration:
    desc: Run integration tests (Docker required)
    cmds:
      - go test ./internal/... -tags=integration -v -count=1 -timeout 300s

  test:e2e:
    desc: Run E2E API tests (full server + real DB)
    cmds:
      - go test ./test/e2e/ -tags=integration -v -count=1 -timeout 300s

  test:all:
    desc: Run all tests (unit + integration + e2e)
    cmds:
      - task: test:unit
      - task: test:integration
      - task: test:e2e

  # --- Documentation ---
  docs:swagger:
    desc: Generate Swagger/OpenAPI docs
    cmds:
      - swag init -g cmd/server/main.go -o docs --parseDependency --parseInternal

  # --- Quality ---
  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run

  fmt:
    desc: Format code with gofumpt
    cmds:
      - gofumpt -w .

  # --- Dependencies ---
  vendor:
    desc: Tidy and vendor dependencies
    cmds:
      - go mod tidy
      - go mod vendor

  clean:
    desc: Remove build artifacts
    cmds:
      - rm -rf {{.BIN_DIR}} output/
```

---

## 14. Architecture Rules (Checklist)

1. **Config tags:** Every config struct field has `yaml`, `mapstructure`, and `validate` tags.
2. **OTelConfig isolation:** `OTelConfig *otel.Config` always tagged `yaml:"-" mapstructure:"-"`. Never serialized.
3. **OTel injection:** OTelConfig is set at runtime via functional options or direct assignment — never from YAML/env.
4. **Layer separation:** Handler → Service → Repository. No skipping layers. Handlers never touch `*gorm.DB` directly.
5. **LayerContext usage:** Every service/repository method starts with `otel.Layers.Start*()` and defers `lc.End()`.
6. **Context propagation:** Always pass `lc.Context()` to downstream calls, never the original `ctx`.
7. **DTO mapping:** Handlers use DTOs (`handler/dto.go`) for request/response. GORM models stay in `model/`. Map between them in handlers or services.
8. **Exported DTOs:** Request/Response structs in `handler/dto.go` must be exported (capitalized) for `swag` to parse.
9. **Swagger annotations:** Every handler method has `@Summary`, `@Tags`, `@Param`, `@Success`, `@Failure`, `@Router`, and `@Security` (where applicable).
10. **E2E tests exist:** `test/e2e/` contains full-stack API tests using `startTestServer(t)` with testcontainer DB.
11. **`.http` file exists:** `http/api.http` covers every API endpoint with example payloads.
12. **Migration naming:** `{6-digit sequence}_{description}.{up|down}.sql` with `embed.FS`.
13. **Test assertions:** Use `testify/assert` and `testify/require` — never `if err != nil { t.Fatal() }` patterns for assertions.
14. **Error returns:** `lc.Error(err, msg)` returns `error` — use it as a return value. `lc.Success(msg)` returns nothing.
15. **Temporal separation:** Workflow functions use `workflow.Context`, activity functions use `context.Context`. Activities hold injected dependencies via a struct. Worker binary lives in `cmd/worker/`, separate from the API server.
16. **Temporal config:** `temporal.Config` has no `OTelConfig` field — it is fully serializable. Embed as a value type in `AppConfig`, not a pointer.

---

## 15. Dependency Quick Reference

| Need | Package | Key API |
|------|---------|---------|
| Configuration | `config` | `config.LoadString[T](yaml, prefix...)` |
| OpenTelemetry | `otel` | `otel.NewConfig(name)`, `otel.Layers.Start*()`, `otel.F(k, v)` |
| OTel Logging | `otel` | `otel.NewLoggerProviderWithOptions(name, opts...)` |
| Legacy Logging | `logging` | `logging.Initialize(name, debug)` |
| Database Pool | `db` | `db.ConnectionConfig{...}.Pool()` |
| Migrations | `db` | `db.RunPostgresMigrationsWithGorm(ctx, pool, fs, path)` |
| HTTP Server | `server` | `server.StartWithConfig(cfg)`, `server.DefaultConfig(port, op, shut)` |
| gRPC Server | `grpc` | `grpc.New(opts...)`, `grpc.Start(port, registrar, opts...)` |
| REST Client | `rest` | `rest.NewClient(opts...)`, `client.MakeRequestWithTrace(...)` |
| Retry | `retry` | `retry.Do(ctx, cfg, op)`, `retry.DefaultConfig().WithName(n).WithOTel(c)` |
| Concurrency | `concurrent` | `concurrent.ExecuteConcurrently(ctx, funcs)` |
| Temporal Client | `temporal` | `temporal.NewClient(cfg)`, `temporal.NewClientWithMetrics(cfg, bool)` |
| Temporal Worker | `temporal` | `temporal.NewWorkerManager(cfg)`, `wm.Register(queue, opts)` |
| Temporal Schedule | `temporal` | `temporal.NewScheduleManager(client)`, `sm.CreateWorkflowSchedule(...)` |
| Temporal Test | `temporal/testcontainer` | `testcontainer.Setup(ctx, cfg, opts)` |
| Docker | `docker` | `docker.New(opts...)`, `docker.NewFromRequest(req)` |

---

## 16. Complete Wiring Example

```go
package main

import (
    "context"
    "flag"
    "log"

    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    echoSwagger "github.com/swaggo/echo-swagger"

    "myapp/internal/config"
    "myapp/internal/handler"
    "myapp/internal/repository"
    "myapp/internal/service"
    "myapp/migrations"

    "github.com/jasoet/pkg/v2/db"
    "github.com/jasoet/pkg/v2/otel"
    "github.com/jasoet/pkg/v2/server"

    _ "myapp/docs" // swagger generated docs
)

// @title My App API
// @version 1.0
// @description REST API for My App
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Enter your session token with the `Bearer ` prefix
func main() {
    configPath := flag.String("config", "config.yaml", "path to config file")
    flag.Parse()

    // --- Config ---
    cfg, err := config.Load(*configPath)
    if err != nil {
        log.Fatalf("failed to load config: %v", err)
    }

    // --- OpenTelemetry ---
    otelCfg := otel.NewConfig("myapp")
    // Attach real providers here if needed:
    // otelCfg = otelCfg.WithTracerProvider(tp).WithMeterProvider(mp)

    // --- Database ---
    cfg.Database.OTelConfig = otelCfg
    pool, err := cfg.Database.Pool()
    if err != nil {
        log.Fatalf("failed to connect to database: %v", err)
    }

    // --- Migrations ---
    if err := db.RunPostgresMigrationsWithGorm(context.Background(), pool, migrations.FS, "."); err != nil {
        log.Fatalf("failed to run migrations: %v", err)
    }

    // --- Repositories ---
    userRepo := repository.NewUserRepo(pool)

    // --- Services ---
    userSvc := service.NewUserService(userRepo)

    // --- Handlers ---
    userHandler := handler.NewUserHandler(userSvc)

    // --- Server ---
    server.StartWithConfig(server.Config{
        Port:            cfg.Server.Port,
        ShutdownTimeout: cfg.Server.ShutdownTimeout,
        Middleware: []echo.MiddlewareFunc{
            middleware.Recover(),
            middleware.Logger(),
        },
        EchoConfigurer: func(e *echo.Echo) {
            e.GET("/swagger/*", echoSwagger.WrapHandler)

            apiV1 := e.Group("/api/v1")
            userHandler.RegisterRoutes(apiV1.Group("/users"))
        },
        Operation: func(e *echo.Echo) {},
        Shutdown: func(e *echo.Echo) {
            log.Println("Shutting down...")
            if sqlDB, err := pool.DB(); err == nil {
                _ = sqlDB.Close()
            }
            _ = otelCfg.Shutdown(context.Background())
        },
    })
}
```

This example demonstrates the full bootstrap sequence: config → OTel → database → migrations → repositories → services → handlers → routes → server start.
