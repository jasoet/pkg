version: '3'

vars:
  PODMAN_SOCKET:
    sh: |
      if command -v podman &> /dev/null; then
        podman machine inspect --format '{{"{{"}}.ConnectionInfo.PodmanSocket.Path{{"}}"}}' 2>/dev/null || echo ""
      fi
  CONTAINER_HOST:
    sh: |
      # Use existing DOCKER_HOST if set
      if [ -n "$DOCKER_HOST" ]; then
        echo "$DOCKER_HOST"
        exit 0
      fi
      # Try native Docker
      if command -v docker &> /dev/null && docker ps &> /dev/null 2>&1; then
        echo ""
        exit 0
      fi
      # Try Podman socket
      if command -v podman &> /dev/null; then
        SOCKET=$(podman machine inspect --format '{{"{{"}}.ConnectionInfo.PodmanSocket.Path{{"}}"}}' 2>/dev/null || echo "")
        if [ -n "$SOCKET" ] && [ -S "$SOCKET" ]; then
          echo "unix://$SOCKET"
          exit 0
        fi
      fi
      echo ""

tasks:
  default:
    desc: List all available tasks
    silent: true
    cmds:
      - task --list

  vendor:
    desc: Run go mod vendor
    silent: true
    cmds:
      - go mod tidy
      - go mod vendor

  test:
    desc: Run unit tests with coverage
    silent: true
    cmds:
      - mkdir -p output
      - go test -race -count=1 -coverprofile=output/coverage.out -covermode=atomic ./... -tags=!examples
      - go tool cover -html=output/coverage.out -o output/coverage.html
      - 'echo "‚úì Coverage: output/coverage.html"'

  test:integration:
    desc: Run integration tests including temporal (testcontainers, Docker or Podman required)
    silent: true
    deps: [docker:check]
    env:
      DOCKER_HOST: '{{.CONTAINER_HOST}}'
      TESTCONTAINERS_RYUK_DISABLED: '{{if .CONTAINER_HOST}}true{{end}}'
    cmds:
      - mkdir -p output
      - go list ./... | grep -v examples | xargs go test -race -count=1 -coverprofile=output/coverage-integration.out -covermode=atomic -tags=integration -timeout=15m
      - go tool cover -html=output/coverage-integration.out -o output/coverage-integration.html
      - 'echo "‚úì Integration coverage: output/coverage-integration.html"'

  test:argo:
    desc: Run Argo integration tests (requires k8s cluster with Argo Workflows)
    silent: true
    cmds:
      - task: argo:check
      - mkdir -p output
      - go test -race -count=1 -coverprofile=output/coverage-argo.out -covermode=atomic -tags=argo -timeout=15m ./argo/...
      - go tool cover -html=output/coverage-argo.out -o output/coverage-argo.html
      - 'echo "‚úì Argo coverage: output/coverage-argo.html"'
      - go tool cover -func=output/coverage-argo.out | grep total

  test:complete:
    desc: Run ALL tests (unit + integration + argo) with single comprehensive coverage report
    silent: true
    deps: [docker:check]
    env:
      DOCKER_HOST: '{{.CONTAINER_HOST}}'
      TESTCONTAINERS_RYUK_DISABLED: '{{if .CONTAINER_HOST}}true{{end}}'
    cmds:
      - task: argo:check
      - mkdir -p output
      - echo "üß™ Running all tests (unit + integration + argo)..."
      - go list ./... | grep -v examples | xargs go test -race -count=1 -coverprofile=output/coverage-complete.out -covermode=atomic -tags=integration,argo -timeout=20m -v
      - go tool cover -html=output/coverage-complete.out -o output/coverage-complete.html
      - 'echo ""'
      - 'echo "‚úÖ Complete test coverage report:"'
      - go tool cover -func=output/coverage-complete.out | grep total
      - 'echo "üìÑ HTML Report: output/coverage-complete.html"'
      - 'echo "üìÑ Coverage Data: output/coverage-complete.out"'

  docker:check:
    desc: Check Docker or Podman availability and daemon status
    silent: true
    cmds:
      - |
        # 1. If DOCKER_HOST is already set by user, trust it
        if [ -n "$DOCKER_HOST" ]; then
          echo "‚úÖ DOCKER_HOST is set: $DOCKER_HOST"
          exit 0
        fi

        # 2. Try native Docker
        if command -v docker &> /dev/null && docker ps &> /dev/null 2>&1; then
          echo "‚úÖ Docker is available and running"
          docker --version
          exit 0
        fi

        # 3. Try Podman via detected socket
        CONTAINER_HOST="{{.CONTAINER_HOST}}"
        if [ -n "$CONTAINER_HOST" ]; then
          echo "‚úÖ Podman is available"
          podman --version
          echo "   Container host: $CONTAINER_HOST"
          exit 0
        fi

        # 4. Podman is installed but socket not found
        if command -v podman &> /dev/null; then
          echo "‚ùå Podman is installed but no running machine detected"
          echo "   Start with: podman machine start"
          exit 1
        fi

        echo "‚ùå Neither Docker nor Podman found"
        echo "   Install Docker or Podman and try again"
        exit 1

  lint:
    desc: Run golangci-lint
    silent: true
    cmds:
      - golangci-lint run ./...

  check:
    desc: Run all checks (test + lint)
    silent: true
    cmds:
      - task: test
      - task: lint

  # Infrastructure checks
  k8s:check:
    desc: Check Kubernetes cluster availability
    silent: true
    cmds:
      - |
        if ! command -v kubectl &> /dev/null; then
          echo "‚ùå kubectl not installed"
          exit 1
        fi
        if kubectl cluster-info &> /dev/null; then
          echo "‚úÖ Kubernetes cluster is available"
          kubectl cluster-info | head -2
          echo "   Context: $(kubectl config current-context)"
        else
          echo "‚ùå Kubernetes cluster not accessible"
          echo "   Check your kubeconfig or cluster status"
          exit 1
        fi

  argo:check:
    desc: Check Argo Workflows availability in cluster
    silent: true
    cmds:
      - |
        if ! command -v kubectl &> /dev/null; then
          echo "‚ùå kubectl not installed"
          exit 1
        fi
        if ! kubectl cluster-info &> /dev/null; then
          echo "‚ùå Kubernetes cluster not accessible"
          exit 1
        fi
        if kubectl get namespace argo &> /dev/null; then
          echo "‚úÖ Argo namespace exists"
          if kubectl get deployment -n argo 2> /dev/null | grep -q workflow-controller; then
            echo "‚úÖ Argo Workflows is installed"
            kubectl get pods -n argo -l app=workflow-controller --no-headers 2>/dev/null | head -1
          else
            echo "‚ö†Ô∏è  Argo namespace exists but Argo Workflows not detected"
          fi
        else
          echo "‚ùå Argo namespace not found"
          echo "   Install: kubectl create namespace argo"
          echo "   Then install Argo Workflows from https://argo-workflows.readthedocs.io"
          exit 1
        fi

  # Utilities
  tools:
    desc: Install development tools
    silent: true
    cmds:
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
      - go install github.com/securego/gosec/v2/cmd/gosec@latest
      - go install mvdan.cc/gofumpt@latest
      - echo "‚úì Tools installed"

  fmt:
    desc: Format all Go files with gofumpt
    cmds:
      - gofumpt -l -w .

  clean:
    desc: Clean build artifacts
    silent: true
    cmds:
      - rm -rf dist output
